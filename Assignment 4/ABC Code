// ABC FUNCTIONS
function abcIteration() {
    while (acceptedParameters.length < acceptedPopulationSize) { // Keep sampling until enough accepted parameters 
        let sampledParameters = sampleParameters(); 
        RunSimulation(sampledParameters); 

        let distance = calculateDistance(orderParameter);

        if (distance <= distanceThreshold) {
            acceptedParameters.push(sampledParameters);
            shouldUpdateSimulation = true; // Signal p5.js to start a new simulation
        }

        // Reset for the next simulation within the iteration
        orderParameter = [];
        neighborDistances = [];
        timeStep = 0;
    }

    // Optional: Update your priors based on acceptedParameters
    updatePriors(acceptedParameters);

    acceptedParameters = []; // Reset for the next ABC iteration
}

function RunSimulation() {
    // Reset the swarm
    Scene.swarm = [] 

    // Main simulation loop
    for (let t = 0; t < numSteps; t++) {
        // Step Boid simulation
        for (let p of Scene.swarm) {
            p.step(cohesionStrength, separationStrength, alignmentStrength); 
        }

        // Calculate and store metrics
        orderParameter.push(calculateOrderParameter());
        neighborDistances.push(calculateNearestNeighborDistances());


        timeStep++;
    }


    shouldUpdateSimulation = true; // Signal p5.js to start a new simulation
}

function calculateDistance(simulatedOrderParameter, targetOrderParameter = 1) {
    return Math.abs(simulatedOrderParameter - targetOrderParameter);
}

function sampleParameters() {
    let cohesion = random(cohesionPrior[0], cohesionPrior[1]);
    let alignment = random(alignmentPrior[0], alignmentPrior[1]);
    let separation = random(separationPrior[0], separationPrior[1]);

    return { cohesion, alignment, separation };
}

function updatePriors(acceptedParameters) {
    // Simple approach: Calculate mean and standard deviation of accepted parameters
    let newCohesionMean = 0;
    let newAlignmentMean = 0;
    let newSeparationMean = 0;
    let newCohesionStdDev = 0;
    let newAlignmentStdDev = 0;
    let newSeparationStdDev = 0;

    for (let params of acceptedParameters) {
        newCohesionMean += params.cohesion;
        newAlignmentMean += params.alignment;
        newSeparationMean += params.separation;
    }

    newCohesionMean /= acceptedParameters.length;
    newAlignmentMean /= acceptedParameters.length;
    newSeparationMean /= acceptedParameters.length;

    for (let params of acceptedParameters) {
        newCohesionStdDev += Math.pow(params.cohesion - newCohesionMean, 2);
        newAlignmentStdDev += Math.pow(params.alignment - newAlignmentMean, 2);
        newSeparationStdDev += Math.pow(params.separation - newSeparationMean, 2);
    }

    newCohesionStdDev = Math.sqrt(newCohesionStdDev / acceptedParameters.length);
    newAlignmentStdDev = Math.sqrt(newAlignmentStdDev / acceptedParameters.length);
    newSeparationStdDev = Math.sqrt(newSeparationStdDev / acceptedParameters.length);

    // Update priors (adjust tightness based on your desired convergence)
    cohesionPrior = [newCohesionMean - newCohesionStdDev, newCohesionMean + newCohesionStdDev];
    alignmentPrior = [newAlignmentMean - newAlignmentStdDev, newAlignmentMean + newAlignmentStdDev];
    separationPrior = [newSeparationMean - newSeparationStdDev, newSeparationMean + newSeparationStdDev];
}

function ABC_output() { 
    console.log("----------------");
    console.log(`ABC Iteration: ${acceptedParameters.length}/${acceptedPopulationSize}`);
    if (acceptedParameters.length > 0) {
        let latestParams = acceptedParameters[acceptedParameters.length - 1];
        console.log(`Cohesion: ${latestParams.cohesion.toFixed(2)}`);
        console.log(`Alignment: ${latestParams.alignment.toFixed(2)}`);
        console.log(`Separation: ${latestParams.separation.toFixed(2)}`);
        console.log(`Distance: ${calculateDistance(orderParameter).toFixed(2)}`);
    }
}